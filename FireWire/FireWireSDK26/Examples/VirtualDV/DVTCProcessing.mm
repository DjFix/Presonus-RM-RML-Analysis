/*	File:		DVTCProcessing.mm  Synopsis: This file implements some DV timecode processing  	Copyright: 	© Copyright 2001-2005 Apple Computer, Inc. All rights reserved. 	Written by: ayanowitz  Disclaimer:	IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc. ("Apple") in consideration of your agreement to the following terms, and your use, installation, modification or redistribution of this Apple software constitutes acceptance of these terms.  If you do not agree with these terms, please do not use, install, modify or redistribute this Apple software.  In consideration of your agreement to abide by the following terms, and subject to these terms, Apple grants you a personal, non-exclusive license, under Apple’s copyrights in this original Apple software (the "Apple Software"), to use, reproduce, modify and redistribute the Apple Software, with or without modifications, in source and/or binary forms; provided that if you redistribute the Apple Software in its entirety and without modifications, you must retain this notice and the following text and disclaimers in all such redistributions of the Apple Software.  Neither the name, trademarks, service marks or logos of Apple Computer, Inc. may be used to endorse or promote products derived from the Apple Software without specific prior written permission from Apple.  Except as expressly stated in this notice, no other rights or licenses, express or implied, are granted by Apple herein, including but not limited to any patent rights that may be infringed by your derivative works or by other works in which the Apple Software may be incorporated.  The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.  IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */// Revised 12-8-2003, adding DVCPROHD 60fps support (based on difChannel)#include <stdio.h>#include <CoreFoundation/CoreFoundation.h>typedef unsigned char uint8;//-----------------------------------------------------------------------------------------------------------------// forward declarations//-----------------------------------------------------------------------------------------------------------------	// timecode element callback proc	//-------------------------------------------------------------------------------------------------------------	// DV Timecode Storage Notes:	// --------------------------	//	// The first 3 bytes of each subcode block contain header information, while the	// last 29 bytes of each subcode block are usually 0xFF, and can also be ignored.	//	// The remaining 48 bytes are divided into blocks of 8, with a 3 byte subcode at	// the front, and a 5-byte subcode at the end.  The 5-byte subcode is what we're	// interested in, as it contains the timecode blocks.	//	// Here is the basic structure of one of these 5-byte subcode blocks:	//	//		[HEADER][FRAMES/FLAGS][SECONDS][MINUTES][HOURS]	//	//-------------------------------------------------------------------------------------------------------------	// DV Timecode Structure Notes:	// ----------------------------	//	NTSC:	//		pack[0]	0	0	0	1	0	0	1	1 (header 0x13)	//		pack[1]	CF	DF	[10s f ][1s frames	  ]	//		pack[2]	PC	[ 10s sec  ][1s seconds	  ]	//		pack[3]	BGF0[ 10s min  ][1s minutes	  ]	//		pack[4]	BGF2BGF1[10s h ][1s hours	  ]	//	//	PAL:	//		pack[0]	0	0	0	1	0	0	1	1 (header 0x13)	//		pack[1]	CF	?	[10s f ][1s frames	  ]	//		pack[2]	BGF0[ 10s sec  ][1s seconds	  ]	//		pack[3]	BGF2[ 10s min  ][1s minutes	  ]	//		pack[4]	PC	BGF1[10s h ][1s hours	  ]	//	//-------------------------------------------------------------------------------------------------------------	//-------------------------------------------------------------------------------------------------------------	// constants	//-------------------------------------------------------------------------------------------------------------			// timecode pack constants		#define kTimeCodeID				0x13		#define kDropFrameBit			0x40				// subcode offsets		#define kFirstSubcodeDIFBlock	1		#define kNumSubcodeDIFBlocks	2				// pack constants		#define kGeneralPackSize		5		#define kSubcodePackSize		8		#define kSubcodePackDataOffset	3		#define kSubcodeDataSize		5						// DIF sequence constants		#define kNumDIFBlocksPerSequence	150		#define kNumBytesPerDIFBlock		80		#define kNumBytesPerSequence		(kNumBytesPerDIFBlock*kNumDIFBlocksPerSequence)		//-------------------------------------------------------------------------------------------------------------	// local utility function declarations	//-------------------------------------------------------------------------------------------------------------			static unsigned int ConvertToBCD(unsigned int number);		static unsigned int ConvertFromBCD(unsigned int number);		static double LocalTimeCodeRolloverSimple(int frameBase, Boolean dropframe, double baseValue);		static unsigned int DVTimecodeExtractDropAdjust( unsigned int frameNumber);		static unsigned int DVTimecodeInsertionDropAdjust( unsigned int frameNumber, Boolean addOffset);//-----------------------------------------------------------------------------------------------------------------// Exported Functions//-----------------------------------------------------------------------------------------------------------------	// Extraact Timecode From a DV Frame	//-------------------------------------------------------------------------------------------------------------	int DVExtractTimeCodeFromFrame( void * pFrameData, int numDIFSequences, Boolean ntscRate, long timeBase, 									void *pReturnSubcode, int *pFrameCount, int *pHours, int *pMinutes, 									int *pSeconds, int *pFrames, Boolean *pIsDropFrame) {				// locals		int				result = 0;		unsigned char	*dataPtr = (uint8*)pFrameData;			// working source data pointer		unsigned char	*difSeqPtr = 0;		// working pointers		unsigned char	*difBlockPtr, *packPtr;		// working pointers		unsigned long	seqCounter = 0, difBlockCounter = 0;	// counter and total of dif blocks to check		unsigned long	byteCounter = 0;		Boolean			found = FALSE, isDropFrame = FALSE;		unsigned int	localHours = 0, localMinutes = 0;		unsigned int	localSeconds = 0, localFrames = 0;		unsigned int	localFrameNumber = 0;		unsigned int	difChannel = 0;				// walk the sequence blocks in this frame...		for (seqCounter = 0; seqCounter< (unsigned int) numDIFSequences && found == FALSE; seqCounter++)						// get sequence pointer			difSeqPtr = dataPtr + seqCounter * kNumBytesPerSequence;						// search specific DIF blocks			for (difBlockCounter = 0; difBlockCounter<kNumSubcodeDIFBlocks && found == FALSE; difBlockCounter++) {								// get base pointers				difBlockPtr = (difSeqPtr + ((difBlockCounter+kFirstSubcodeDIFBlock) * kNumBytesPerDIFBlock));								// if we're doing 60fps, figure out which DIF channel this is				if (timeBase == 60)					switch (difBlockPtr[1] & 0x0F) {						case 0x07:	difChannel = 0;		break;						case 0x0F:	difChannel = 1;		break;						case 0x03:	difChannel = 2;		break;						case 0x0B:	difChannel = 3;		break;						default:	difChannel = 0;		// this shouldn't happen, but we need a default case					}												// iterate over the packs						for (byteCounter = kSubcodePackDataOffset; byteCounter<(kNumBytesPerDIFBlock-kSubcodePackSize) 							&& found == FALSE; byteCounter += kSubcodePackSize) {														// get a pointer to the pack							packPtr = difBlockPtr + (byteCounter+kSubcodePackDataOffset);														// is this a timecode pack?							if (((*packPtr) == kTimeCodeID)) {																// is this a drop or non-drop timecode?								if ((timeBase == 30) && (ntscRate == TRUE) && (packPtr[1] & kDropFrameBit))									isDropFrame = TRUE;								else									isDropFrame = FALSE;																// get the number of frames (re-interpret based on timebase for 60p)								localFrames = (ConvertFromBCD((packPtr[1] & 0x3F)));								if (timeBase == 60) {									localFrames *= 2;						// double frame count									if (difChannel == 2 || difChannel == 3)										localFrames += 1;					// if we're on the SECOND 2 DIF channels, this is the odd frame								}																// extract the individual numbers								localSeconds = ConvertFromBCD((packPtr[2] & 0x7F));								localMinutes = ConvertFromBCD((packPtr[3] & 0x7F));								localHours = ConvertFromBCD((packPtr[4] & 0x3F));																// compute a frame count								localFrameNumber = (localFrames);								localFrameNumber += (localSeconds * timeBase);								localFrameNumber += (localMinutes * timeBase * 60);								localFrameNumber += (localHours * timeBase * 60 * 60);																// reverse the drop frame calculations								if (isDropFrame == TRUE && timeBase == 30 && ntscRate == TRUE)									localFrameNumber = DVTimecodeExtractDropAdjust(localFrameNumber);																// make sure TC is valid, and then return it								if (localFrameNumber < (unsigned int) (timeBase * 60 * 60 * 24)) {																		// return data									if (pReturnSubcode != NULL)	memcpy(packPtr, pReturnSubcode, kGeneralPackSize);									if (pFrameCount != NULL)	(*pFrameCount) = localFrameNumber;									if (pHours != NULL)			(*pHours) = localHours;									if (pMinutes != NULL)		(*pMinutes) = localMinutes;									if (pSeconds != NULL)		(*pSeconds) = localSeconds;									if (pFrames != NULL)		(*pFrames) = localFrames;									if (pIsDropFrame != NULL)	(*pIsDropFrame) = isDropFrame;																		// set found flag									found = TRUE;								}							}						}			}						// return error state			return (result);				} // DVExtractTimeCodeFromFrame	//-------------------------------------------------------------------------------------------------------------	// Insert Timecode into EXISTING Timecode Packs Within A DV Frame	// --------------------------------------------------------------	// NOTE: The priority/ordering of the parameters is as follows:	//	//  - If pSubcodeData is non-null, it will be used (expected to point to a 5-byte Timecode Pack).	//  - If pFrameCount is non-null, it will be converted into H:M:S:F, optionally using pIsDropFrame for NTSC.	//  - pHours, pMinutes, pSeconds and pFrames will be used if the prior 2 argumens are NULL.	//	// If all parameters are NULL, then an error will be returned	//	//-------------------------------------------------------------------------------------------------------------	int DVInsertTimeCodeIntoFrame( void *pFrameData, int numDIFSequences, Boolean isPAL, void *pSubcodeData, 									unsigned int *pFrameCount, unsigned int *pHours, unsigned int *pMinutes, 									unsigned int *pSeconds, unsigned int *pFrames, Boolean *pIsDropFrame) {				// locals		int				result = 0;		unsigned char	*dataPtr = (uint8*)pFrameData;			// working source data pointer		unsigned char	*difSeqPtr, *difBlockPtr, *packPtr;		// working pointers		unsigned long	seqCounter = 0, difBlockCounter = 0;	// counter and total of dif blocks to check		unsigned long	byteCounter = 0;		long			timeBase = ((isPAL==TRUE)?(25):(30));		Boolean			isDropFrame = ((pIsDropFrame!=NULL) && (*pIsDropFrame == TRUE))?(TRUE):(FALSE);		unsigned int	localHours = 0, localMinutes = 0;		unsigned int	localSeconds = 0, localFrames = 0;		unsigned int	localFrameNumber = 0;				unsigned char	finalPackData[5];						// check arguments (basic)		if (pFrameData == NULL) return (1);				// construct (or re-use) a 5-byte Timecode Pack		if (pSubcodeData != NULL) {					// clone the data and reset the packID (just to be sure)			memcpy(pSubcodeData, finalPackData, kGeneralPackSize);			finalPackData[0] = kTimeCodeID;			} else if (pFrameCount != NULL) {					// ensure the frame number is valid (ensure we're not going over 24 hours)			localFrameNumber = (unsigned int) LocalTimeCodeRolloverSimple(				(timeBase),			// 30 or 25 (NTSC/PAL)				(isDropFrame),		// Drop Frame or Non-Drop Frame				(*pFrameCount));	// raw frame count							// if we're using drop-frame, adjust the frame count accordingly			if (timeBase == 30 && isDropFrame == TRUE)				localFrameNumber = DVTimecodeInsertionDropAdjust(localFrameNumber, TRUE);				// extract component numbers			localFrames = (localFrameNumber % (timeBase));			localSeconds = ((localFrameNumber / (timeBase)) % 60);			localMinutes = ((localFrameNumber / ((timeBase) * 60)) % 60);			localHours = ((localFrameNumber / ((timeBase) * 60 * 60)) % 24);				// reset the parmeter pointers to our local count values (allows us to re-use some code			pFrames = &localFrames;			pSeconds = &localSeconds;			pMinutes = &localMinutes;			pHours = &localHours;		}				// if we didn't get a pre-build timecode pack, construct one now...		if (pSubcodeData == NULL)			if (pHours != NULL && pMinutes != NULL && pSeconds != NULL && pFrames != NULL) {							// convert the components into BCDs				localFrames = ConvertToBCD((*pFrames));				localSeconds = ConvertToBCD((*pSeconds));				localMinutes = ConvertToBCD((*pMinutes));				localHours = ConvertToBCD((*pHours));					// stash the values into the final pack structure (this will, itself, be OR'd with existing fields)				memset(finalPackData, 0, 5);				finalPackData[0] = kTimeCodeID;				finalPackData[1] = (((timeBase == 30 && isDropFrame == TRUE)?kDropFrameBit:0) | (localFrames));				finalPackData[2] = (localSeconds);				finalPackData[3] = (localMinutes);				finalPackData[4] = (localHours);				} else { return (1); /* something went horribly wrong (like no params), so return an error */ }				// walk the sequence blocks in this frame...		for (seqCounter = 0; seqCounter<(unsigned int)numDIFSequences; seqCounter++) {					// get sequence pointer			difSeqPtr = dataPtr + seqCounter * kNumBytesPerSequence;				// search specific DIF blocks			for (difBlockCounter = 0; difBlockCounter<kNumSubcodeDIFBlocks; difBlockCounter++) {							// get base pointers				difBlockPtr = (difSeqPtr + ((difBlockCounter+kFirstSubcodeDIFBlock) * kNumBytesPerDIFBlock));								// iterate over the packs				for (byteCounter = kSubcodePackDataOffset; byteCounter<(kNumBytesPerDIFBlock-kSubcodePackSize); byteCounter += kSubcodePackSize) {						// get a pointer to the pack					packPtr = difBlockPtr + (byteCounter+kSubcodePackDataOffset);										// is this a timecode pack?					if (((*packPtr) == kTimeCodeID)) {											// reset the proper bits, trying to not change any padding bits						// (they're inconsistent between formats anyway)						packPtr[1] = ((packPtr[1] & 0x80) | finalPackData[1]);						packPtr[2] = ((packPtr[2] & 0x80) | finalPackData[2]);						packPtr[3] = ((packPtr[3] & 0x80) | finalPackData[3]);						packPtr[4] = ((packPtr[4] & 0xC0) | finalPackData[4]);					}				}			}		}			// return error state		return (result);			} // DVInsertTimeCodeIntoFrame//-----------------------------------------------------------------------------------------------------------------// Internal Utility Functions//-----------------------------------------------------------------------------------------------------------------	// convert an integer to a binary coded decimal	//-------------------------------------------------------------------------------------------------------------	static unsigned int ConvertToBCD( unsigned int number ) {		return(((number / 10) << 4) + (number % 10));	} // ConvertToBCD		//-------------------------------------------------------------------------------------------------------------	// convert a binary coded decimal to an integer	//-------------------------------------------------------------------------------------------------------------	static unsigned int ConvertFromBCD( unsigned int number ) {		return (((number >> 4) * 10) + (number & 0x0F));	} // ConvertFromBCD		//-------------------------------------------------------------------------------------------------------------	// rollover timecode	//-------------------------------------------------------------------------------------------------------------	static double LocalTimeCodeRolloverSimple(int frameBase, Boolean dropframe, double baseValue) {				// locals			double		second = frameBase;		double		minute = (second * 60);		double		hour =  (minute * 60);		double		max = (hour * 24);				// roll timecode over if negative or over 24 hours		if (dropframe && frameBase == 30)			max -= 6*18*24;				while (fabs(baseValue) >= max) {			if (baseValue < 0.0)				baseValue += max;			else				baseValue -= max;		}				// return the final value		return (baseValue);			} // LocalTimeCodeRolloverSimple		//-------------------------------------------------------------------------------------------------------------	// Adjust an incoming frame number to take dropness into account	//	//  NOTE: Drop frame is displayed by dropping the :00 and :01 frame 	//        every minute, except for every 10th minute.	//-------------------------------------------------------------------------------------------------------------	static unsigned int DVTimecodeExtractDropAdjust( unsigned int frameNumber) {				// locals		double			minute = 30 * 60;		unsigned int	fullMins = 0;		double			partMins = 0;				// count number of full minutes of NTSC video segments		fullMins = (unsigned int) (frameNumber / minute);				// determine the remainder beyond the minute boundary		partMins = (frameNumber - (fullMins*minute));				// subtract non-existant frames from frame count		frameNumber -= ((fullMins / 10) * (2*9));	// take 18 frames for each FULL 10 minutes		frameNumber -= ((fullMins % 10) * 2);		// take 2 frames for each remaining minute				// return frame number		return(frameNumber);			} // DVTimecodeExtractDropAdjust		//-------------------------------------------------------------------------------------------------------------	// Adjust an outgoing frame number to take dropness into account	//	//  NOTE: Drop frame is displayed by dropping the :00 and :01 frame 	//        every minute, except for every 10th minute.	//-------------------------------------------------------------------------------------------------------------	static unsigned int DVTimecodeInsertionDropAdjust( unsigned int frameNumber, Boolean addOffset) {				double		minute = 30 * 60;		int			tenmins, mins;		int			minadj = 0;		double		tempframes;				// drop frame is displayed by dropping the :00 and :01 frame every minute,		// except for every 10th minute				// count number of full 10 minute NTSC video		tenmins = (int) (frameNumber / ((minute * 10) - 2*9));		// count remaining video		tempframes = frameNumber - ((double)tenmins * ((minute * 10) - 2*9));		mins = (int) (tempframes / (minute - 2));		if (mins > 0) {			if (mins >= 10) {				minadj = 9*2;			}			else {				switch ((int)tempframes % ((int)minute - 2)) {					case 0:					case 1:						minadj = (mins - 1) * 2;						break;					default:						minadj = mins * 2;						break;				}			}		}				// add or remove 18 frames for each ten minutes, plus 2 frames for each minute beyond		if (addOffset)			frameNumber += (tenmins * 2 * 9) + minadj;		else			frameNumber -= (tenmins * 2 * 9) + minadj;				return(frameNumber);			} // DVTimecodeInsertionDropAdjust	